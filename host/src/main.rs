// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    METHOD_ELF, METHOD_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use anyhow::Result;
use clap::{command, Parser};
use helios::consensus::rpc::ConsensusRpc;
use risc0_helios_core::script::{
    get_checkpoint, get_client, get_execution_state_root_proof, get_latest_checkpoint, get_updates,
};
use risc0_helios_core::primitives::types::{ProofInputs, ProofOutputs};
use alloy_sol_types::SolType;


#[derive(Parser, Debug, Clone)]
#[command(about = "Get the genesis parameters from a block.")]
pub struct GenesisArgs {
    #[arg(long)]
    pub slot: Option<u64>,
}

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    let args = GenesisArgs::parse();
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    let checkpoint = if let Some(slot) = args.slot {
        get_checkpoint(slot).await
    } else {
        get_latest_checkpoint().await
    };


    // Setup client.
    let helios_client = get_client(checkpoint).await;
    let updates = get_updates(&helios_client).await;
    let finality_update = helios_client.rpc.get_finality_update().await.unwrap();
    let latest_block = finality_update.finalized_header.slot;

    println!("Latest block: {:#?}", latest_block);

    let execution_state_root_proof = get_execution_state_root_proof(latest_block).await.unwrap();

    let expected_current_slot = helios_client.expected_current_slot();
    let inputs = ProofInputs {
        updates,
        finality_update,
        expected_current_slot,
        store: helios_client.store.clone(),
        genesis_root: helios_client.config.chain.genesis_root,
        forks: helios_client.config.forks.clone(),
        execution_state_proof: execution_state_root_proof,
    };

    let env = ExecutorEnv::builder()
        .write_slice(&serde_cbor::to_vec(&inputs).unwrap())
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, METHOD_ELF)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // For example:
    let journal: Vec<u8> = receipt.journal.bytes.clone();
    let _output = ProofOutputs::abi_decode(&journal, false).unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(METHOD_ID)
        .unwrap();
    Ok(())
}
